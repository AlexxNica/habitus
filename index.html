<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Habitus by Cloud 66</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Habitus</h1>
      <h2 class="project-tagline">A Docker Build Flow Tool</h2>
      <a href="https://github.com/cloud66/habitus" class="btn">View on GitHub</a>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to Habitus</h3>
<p>Habitus is a standalone Docker build flow tool. It is a command line tool that builds Docker images based on their <code>Dockerfile</code> and a <code>build.yml</code>.</p>

<h4>Build files</h4>
<p>Habitus uses a yml file as a descriptor for builds. Here is an example:</p>

<pre>
  <code>
steps:
  - builder:
    name: builder
    dockerfile: Dockerfile.builder
    artefacts:
      - /go/src/github.com/cloud66/iron-mountain/iron-mountain
      - /go/src/github.com/cloud66/iron-mountain/config.json
      - /go/src/github.com/cloud66/iron-mountain/localhost.crt
      - /go/src/github.com/cloud66/iron-mountain/localhost.key
    cleanup:
      commands:
        - rm -rf /root/.ssh/
  - deployment:
    name: ironmountain
    dockerfile: Dockerfile.deployment
  </code>
</pre>

<p>Build files can be made up of multiple steps. Each step is independent of the other ones and downstream steps can use upstream ones as source (in <code>FROM</code> command).</p>
<p>In the example above, there are two steps: <code>builder</code> and <code>deployment</code>. All steps work out of the same working directory. <code>dockerfile</code> states which Dockerfile is used to build this step.</p>

<p>Here is a list of all step elements:</p>

<ul>
<li><code>order (optional)</code>: Order of the step. This is assigned to the step if missing based on the order in the yml file.</li>
<li><code>name:</code> Name of the generated image</li>
<li><code>dockerfile:</code> Dockerfile used to build the step</li>
<li><code>artefacts:</code> List of all files to be copied out of the image once it's built. See below</li>
<li><code>cleanup:</code> List of all cleanup steps to run on the image once the step is finished. See below</li>
</ul>

<h4>Artefacts</h4>
<p>Artefacts are files to be copied outside of a build image in a step. This can be used when a step is build of a compiled language like Go or Java where the image requires build dependencies. The next step can then use the build step's artefacts in a runtime dependency only image.</p>
<p>Each artefact has two parts: source and destination. Source is the path from within the image and destination where the file will be copied to on the "build server". If destination is missing, the current folder will be used. Full path and file permissions of the source will be preserved during copy. So a file that comes from <code>/app/build/result/abc</code> of the image will go to <code>./app/build/result/abc</code> of the build server if no destination is set.</p>

<p>Here is an example:</p>

<p>
<code>
- /go/src/service/go-service
</code>
</p>

<p>or</p>

<p>
  <code>- /go/src/service/go-service:/tmp/go-service</code>
</p>

<p>Artefacts are copied from the container and can be used with <code>ADD</code> or <code>COPY</code> commands in downstream steps. Habitus copies artefact file permissions as well.</p>

<h4>Cleanup</h4>

<p>Cleanup is a step that runs after the build is finished for a step. At the moment, cleanup is limited to commands:</p>

<pre>
  <code>
cleanup:
  commands:
    - apt-get purge -y man  perl-modules vim-common vim-tiny libpython3.4-stdlib:amd64 python3.4-minimal xkb-data libx11-data eject python3 locales golang-go
    - apt-get clean autoclean
    - apt-get autoremove -y
    - rm -rf /var/lib/{apt,dpkg,cache,log}/
</code>
</pre>

<p>This runs the commands in the provided order on the image and then as a last step squashes the image to remove anything that's been removed. This is particularly useful when it comes to private information like ssh private keys that need to be on the image during the build (to pull git repos for example) but can't be published as part of the built image.</p>

<h4>Image sequencing</h4>

<p>Habitus allows dovetailing (sequencing) of images from different steps. This means a step can use the image built by the previous step as the source in its Dockerfile <code>FROM</code> command. This is done automatically if <code>FROM</code> command refers to an image name used by a previous step.</p>
<p>Habitus automatically parses the <code>FROM</code> image name and replaces it with the correct name when it is used in multi-tenanted setup. This enables multiple builds of the same build file to run in parallel with different session UIDs (see below).</p>

<h4>Environment variables</h4>
<p>Environment variables can be used in the build file with the _env(VAR) format:</p>

<pre>
  <code>
artefacts:
      - /go/src/go-service/_env(SERVICE_NAME)
  </code>
</pre>


<p>This will be replaced before the build file is fed into the build engine. By default Habitus inherits all environment variables of its parent process. This can be overridden by passing environment variables into Habitus explicitly through the env command parameter:</p>

<p><code>$ Habitus -env SERVICE_NAME=abc -env RAILS_ENV=production</code></p>

<h4>Command line parameters</h4>
<p>Habitus accepts the following command line parameters:</p>

<ul>
<li><code>f</code>: Path to the build file. If not specified, it will default to <code>build.yml</code> in the work directory.</li>
<li><code>d</code>: Path to work directory. This is the path where Dockerfiles should exist for each step and the build happens. Defaults to the current directory.</li>
<li><code>no-cache</code>: Don't use docker build caching.</li>
<li><code>suppress</code>: Suppress docker build output.</li>
<li><code>rm</code>: Remove intermediate built images.</li>
<li><code>force-rm</code>: Forcefully remove intermediate images.</li>
<li><code>s</code>: Start step name. It allows starting a build from a middle step. Doesn't work with image sequencing. Defaults to the first step.</li>
<li><code>uid</code>: A unique ID used for a build session to allow multi-tenancy of Habitus</li>
<li><code>level</code>: Logging level. Acceptable values: <code>debug</code>, <code>info</code>, <code>notice</code>, <code>warning</code>, <code>error</code> and critical. Defaults to <code>debug</code></li>
<li><code>host</code>: Address for Docker daemon to run the build. Defaults to the value of <code>$DOCKER_HOST</code>.</li>
<li><code>certs</code>: Path of the key and cert files used to connect to the Docker daemon. Defaults to <code>$DOCKER_CERT_PATH</code></li>
<li><code>env</code>: Environment variables used in the build process. If not specified Habitus inherits all environment variables of the parent process.</li>
<li><code>keep-all</code>: Overrides the keep flag for all steps so you can inspect and debug the created images of each step without changing the build file.</li>
<li><code>no-cleanup</code>: Don't run cleanup commands. This can be used for debugging and removes the need to run as sudo</li>
<li><code>force-rmi</code>: Forces removal of unwanted images after the build</li>
<li><code>noprune-rmi</code>: Doesn't prune unwanted images after the build</li>
</ul>

<h4>Development Environment for Habitus</h4>

<p>Habitus requires running in privileged more (sudo) so it can run the squash method (keeping file permissions across images). It also requires the following environment variables: <code>DOCKER_HOST</code> and <code>DOCKER_CERT_PATH</code>. These are usually available when Docker is running on a machine, but might not be available in sudo mode. To fix this, you can pass them into the app with commandline params:</p>

<p><code>$ sudo Habitus --host $DOCKER_HOST --certs $DOCKER_CERT_PATH</code></p>

<h4>Dependencies</h4>

<p>You would also need <a href="https://www.gnu.org/software/tar/">gnu tar</a> to be available on the machine:</p>

<h5>OSX<h5>

<p><a href="https://github.com/cloud66/habitus/blob/gh-pages/gnu-tar.md">Instructions for OSX</a></p>

<h4>Multi-tenancy for Habitus</h4>
<p>Habitus supports multi-tenancy of builds by using a <code>uid</code> parameter.</p>
<p>All builds and images will be tagged with the <code>uid</code> for this unless a step name explicitly has a tag. In that case the tag is concatenated with the <code>-uid</code>.</p>

<footer class="site-footer">
  <span class="site-footer-owner"><a href="https://github.com/cloud66/habitus">Habitus</a> is maintained by <a href="http://www.cloud66.com">Cloud 66</a>.</span>
</footer>

</section>


  </body>
</html>
